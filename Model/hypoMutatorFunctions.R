# Hypothesis mutator all functions (also for simulation)
# this is basically the implementation of the model

################################################################################
# libraries
###############################################################################
library(ggplot2)
library(cowplot)
library(plyr)
library(ggthemes)
library(ggsignif)
library(gridExtra)
library(ggpubr)
library(here)
library(brms)
library(ggpubr)

#################################################################################
# functions
##############################################################################
# function to generate a trial for the simulation
# conditions can either manipulate task structure or query structure
# the length of each trial is randomly determined from 1-7
generatetrial <- function(structure_task=FALSE, structure_query=FALSE){
  sequence_length = sample(1:7, 1)
  print(sequence_length)
  # normal condition
  if (structure_task==FALSE &  structure_query==FALSE){
    # letter are assigned to sizes randomly
    # target letter is assigned at random
    d <- data.frame(bar=sample(letters[1:sequence_length]), size=1:sequence_length, target=sample(letters[1:sequence_length], 1))
  }
  # structure in the task
  if (structure_task==TRUE &  structure_query==FALSE){
    # initialize unpermuted data frame
    d <- data.frame(bar=letters[1:sequence_length], size=1:sequence_length, target=sample(letters[1:sequence_length], 1))
    # where to insert connected items 
    insert <- sample(1:max(sequence_length-3, 1), 1)
    # scramble the other letters
    l <- sample(letters[1:4], 4)
    # put them together, e-f-g is always connected
    if (insert == 1){
      l <- c(letters[5:7], l)
    }else{
      l <- c(l[1:insert-1], letters[5:7], l[(insert):7])
    }
    # only need the first how ever long the sequence is
    d$bar <- l[1:sequence_length]
    d$target = sample(d$bar, 1)
  }
  # structure in the query
  if (structure_task==FALSE &  structure_query==TRUE){
    # initialize unpermuted frame
    d <- data.frame(bar=sample(letters[1:7]), size=sample(1:7), target=sample(letters[1:7], 1))
    # sample a target that is within the first three sorted bars
    d = d[1:sequence_length,]
    d$size = sample(1:sequence_length)
    d$target <- sample(subset(d, size == max(d$size))$bar, 1) # new version where the tallest bar always gets samples
    
  }
  # randomly permute for giggles
  d <- d[sample(1:sequence_length),]
  # return task data frame
  return(d)
}


# string to vectore: "ab"->[a, b], etc. 
# this will make it easier for the sort later on
string_to_vec <- function(string){
  # initialize empty vector
  out <- numeric()
  # loop over string length
  for (i in 1:nchar(string)){
    # concatenate letters to vector
    out <- c(out, substr(string, i, i))
  }
  # return vector
  return(out)
}

# function for execution of one trial
# trial: generate trial
# threshold: when to stop sorting
# connect string indicating hypotheses of connected letters
execute <- function(trial, threshold, connect, startAtSmall){
  if(startAtSmall==1){# sort given a trial, threshold, and hypotheses
    out <- noisy_sort(trial, threshold, connect)
    # check if sorted response is correct
    correct <- ifelse(which(paste(trial$target[1])==out$collect)==subset(trial, paste(bar)==target)$size, 1, 0)
    # if not present, then it means it stopped too early, which is also incorrect
    correct <- ifelse(length(correct)==0, 0, correct)
    # return time and whether or not correct
    return(data.frame(time = out$time[1], correct = correct))
    
  }else{
    out <- noisy_sort_backwards(trial, threshold, connect)
    # check if sorted response is correct
    correct <- ifelse(which(paste(trial$target[1])==out$collect)==subset(trial, paste(bar)==target)$size, 1, 0)
    # if not present, then it means it stopped too early, which is also incorrect
    correct <- ifelse(length(correct)==0, 0, correct)
    # return time and whether or not correct
    return(data.frame(time = out$time[1], correct = correct))
  }
  
}

# function that replaces bottom 5% with top 5%
die_and_replace <- function(data, fitness){
  # top 5% fittest programs
  top <- (fitness %in% sort(fitness)[1:20])
  # bottom 5% fittest programs
  bottom <- (fitness %in% sort(fitness)[(length(fitness)-19):length(fitness)])
  # replace
  data[bottom==1,] <- data[top==1,]
  # return new data
  return(data)
}

########################################
# bucket sort functions for the noisy sorter
########################################

# bucket sort algorithm should scale 2n if no structure is learned
# trial: trial data frame, generated by generate trial
# threshold: until what point to look at before stopping
# connect: hypothesis about which bars are connected
noisy_sort <- function(trial, threshold = 7, connections = 'a'){
  # create a vector from the connect string
  connections <- string_to_vec(connections)
  connectNotFound = TRUE
  tookConnectAway = FALSE
  # initialize a vector to collect the outcomes of sorting algorithm
  collect <- seq(1, length(trial$bar))
  collect[1:length(collect)] = NaN
  # length of the vector has to be bigger than 1 to make a time-saving connections
  if (length(connections)>1 & connections[1] %in% trial$bar){
    # remove the connected items that comes after the first connect from the to-be-sorted data 
    # that should reduce the data to be sorted and therefore speed up the process
    trial <- subset(trial, !(bar %in% connections[-1]))
    tookConnectAway = TRUE
  }
  # count and time are 0 at start
  count <- 0
  time <- 0
  # number of to-be-sorted rectangles
  nr <- nrow(trial)
  # go through the trials to determine the shortest bar
  MinSize = trial$size[1]
  smallest = 1
  for (i in 1:nrow(trial)){
    # check if current rectangle is smaller than the current smallest rectangle
    if (trial$size[i] < MinSize){
      MinSize = trial$size[i]
      smallest = i
    }
    # increment time
    time <- time + 1
  }
  # add the smallest bar to the list
  collect[1] <- trial$bar[smallest]
  # bar gets removed from consideration set
  trial <- trial[-smallest,]
  # count increments
  count <- count + 1
  # if the hypothesis contained at least two elements
  if (length(connections)>1 & connectNotFound){
    # if the first part was collected
    if(connections[1] %in% collect){
      connectNotFound = FALSE
      # increase the count accordingly
      count <- count + length(connections)-1
    }
  }
  # the count has to be smaller than the threshold or total number of trials
  while (count < pmin(threshold, nr) & length(trial$size) > 0){
    position  <- trial$size[1] # this is the relative size of the bar which allows it to be put in the correct bucket
    collect[position] <- trial$bar[1]
    # bar gets removed from consideration set
    trial <- trial[-1,]
    # count increments
    count <- count + 1
    time = time + 1
    if (length(connections)>1 & connectNotFound){
      # if the first part was collected
      if(connections[1] %in% collect){
        connectNotFound = FALSE
        # increase the count accordingly
        count <- count + length(connections)-1
      }
    }
  }
  
  
  # add the connection if it was found
  if (connectNotFound == FALSE){
    # if the first part was collected
    if(connections[1] %in% collect){
      # mark where it appeared  
      mark <- which(collect == connections[1])
      # bind it together
      if (mark == length(collect)){
        collect <- c(collect, connections[-1])
      }else{
        for (connect in range(1, (length(connections)-1))){
          if (is.nan(as.numeric(collect[(mark+connect)]))){
            collect[(mark+connect)] = connections[(connect+1)]
          } else {
            collect[(mark+connect):(length(collect)+1)] <- c(connections[(connect+1)], collect[(mark+connect):length(collect)])
          }
        }
      }
    }
  }
  
  # attach the rest of the trial in the unsorted order:
  if (connectNotFound & tookConnectAway){
    toInsert <- c(trial$bar, connections[-1])
  } else {
    toInsert <- c(trial$bar)
  }
  foundBar = 1
  for (i in 1:length(collect)){
    if (foundBar == length(toInsert)+1){
      break
    }
    if(is.nan(as.numeric(collect[i]))){
      collect[i] = toInsert[foundBar]
      foundBar = foundBar + 1
    }
  }
  
  
  collect <- collect[!is.nan(as.numeric(collect))]
  print("sorted Sequence")
  print(collect)
  
  # collect into data frame
  dout <- data.frame(collect, time)
  # return data frame
  return(dout)
}


noisy_sort_backwards <- function(trial, threshold = 7, connections = 'a'){
  # create a vector from the connect string
  connections <- string_to_vec(connections)
  connectNotFound = TRUE
  tookConnectAway = FALSE
  # initialize a vector to collect the outcomes of sorting algorithm
  collect <- seq(1, length(trial$bar))
  collect[1:length(collect)] = NaN
  # length of the vector has to be bigger than 1 to make a time-saving connections
  if (length(connections)>1 & connections[1] %in% trial$bar){
    # remove the connected items that comes after the first connect from the to-be-sorted data 
    # that should reduce the data to be sorted and therefore speed up the process
    trial <- subset(trial, !(bar %in% connections[-1]))
    tookConnectAway = TRUE
  }
  # count and time are 0 at start
  count <- 0
  time <- 0
  # number of to-be-sorted rectangles
  nr <- nrow(trial)
  # go through the trials to determine the shortest bar
  MaxSize = trial$size[1]
  tallest = 1
  for (i in 1:nrow(trial)){
    # check if current rectangle is smaller than the current tallest rectangle
    if (trial$size[i] > MaxSize){
      MaxSize = trial$size[i]
      tallest = i
    }
    # increment time
    time <- time + 1
  }
  # add the tallest bar to the list
  collect[length(collect)] <- trial$bar[tallest]
  # bar gets removed from consideration set
  trial <- trial[-tallest,]
  # count increments
  count <- count + 1
  # if the hypothesis contained at least two elements
  if (length(connections)>1 & connectNotFound){
    # if the first part was collected
    if(connections[1] %in% collect){
      connectNotFound = FALSE
      # increase the count accordingly
      count <- count + length(connections)-1
    }
  }
  # the count has to be smaller than the threshold or total number of trials
  while (count < pmin(threshold, nr) & length(trial$size) > 0){
    position  <- trial$size[1] #  this is the relative size of the bar which allows it to be put in the correct bucket
    collect[position] <- trial$bar[1]
    # bar gets removed from consideration set
    trial <- trial[-1,]
    # count increments
    count <- count + 1
    time = time + 1
    if (length(connections)>1 & connectNotFound){
      # if the first part was collected
      if(connections[1] %in% collect){
        connectNotFound = FALSE
        # increase the count accordingly
        count <- count + length(connections)-1
      }
    }
  }
  
  
  # add the connection if it was found
  if (connectNotFound == FALSE){
    # if the first part was collected
    if(connections[1] %in% collect){
      # mark where it appeared  
      mark <- which(collect == connections[1])
      # bind it together
      if (mark == length(collect)){
        collect <- c(collect, connections[-1])
      }else{
        for (connect in range(1, (length(connections)-1))){
          if (is.nan(as.numeric(collect[(mark+connect)]))){
            collect[(mark+connect)] = connections[(connect+1)]
          } else {
            collect[(mark+connect):(length(collect)+1)] <- c(connections[(connect+1)], collect[(mark+connect):length(collect)])
          }
        }
      }
    }
  }
  
  # attach the rest of the trial in the unsorted order:
  if (connectNotFound & tookConnectAway){
    toInsert <- c(trial$bar, connections[-1])
  } else {
    toInsert <- c(trial$bar)
  }
  foundBar = 1
  for (i in 1:length(collect)){
    if (foundBar == length(toInsert)+1){
      break
    }
    if(is.nan(as.numeric(collect[i]))){
      collect[i] = toInsert[foundBar]
      foundBar = foundBar + 1
    }
  }
  
  
  collect <- collect[!is.nan(as.numeric(collect))]
  print("sorted Sequence")
  print(collect)
  
  
  # collect into data frame
  dout <- data.frame(collect, time)
  # return data frame
  return(dout)
}


######################################
# functions for the initialization and mutation of particles
####################################

# function to generate random initial hypothesis
generateRandomParticles= function(nOfParticles, 
                                  nOfBars = 7, 
                                  nOfMaxConnections = 3, 
                                  threshold = TRUE, 
                                  connectedness = TRUE,
                                  startAtSmall = TRUE){
  particles = data.frame(threshold = as.numeric(),
                         conncetions = as.character(),
                         startAtSmall = as.integer()) 
  for(i in 1:nOfParticles){
    if(connectedness){
      # calculate a random number of pieces that are connected
      nOfConnections <- sample(1:nOfMaxConnections,1)
      connection <- paste(letters[1:nOfBars][sample(1:nOfBars,nOfConnections)],collapse = "")
    }else{
      connection <- "a"
    }
    if(threshold){
      newthreshold = sample(1:nOfBars,1)
    }else{
      newthreshold = nOfBars
    }
    if (startAtSmall){
      newstartAtSmall = sample(0:1,1)
    }else{
      newstartAtSmall = 1
    }
    particles=rbind(particles, data.frame(threshold = newthreshold,
                                          connections = connection,
                                          startAtSmall = newstartAtSmall))
  }
  return(particles)
}


mutateParticle = function(particle,
                          nOfBars= 7, 
                          nOfMaxConnections = 3, 
                          threshold = TRUE, 
                          connectedness = TRUE,
                          startAtSmall = TRUE){
  currentConnection = string_to_vec(as.character(particle[1,]$connections))
  currentThreshold = particle[1,]$threshold
  currentStartAtSmall = particle[1,]$startAtSmall
  # pick what to mutate
  if(threshold == FALSE & connectedness == FALSE & startAtSmall == FALSE){
    print("particle could not be mutated, bacause both threshold and connectedness 
          mutations where set to false, change those settings if you want to get mustations.
          Intseatd return the default particle.")
    new_particle = generateRandomParticles(nOfParticles = 1, 
                                           nOfBars= 7, 
                                           nOfMaxConnections = 3, 
                                           threshold = FALSE, 
                                           connectedness = FALSE,
                                           startAtSmall = FALSE)
    return(particle)
  }else if (threshold == FALSE & startAtSmall == FALSE){
    mutation = "connectedness"
  }else if (connectedness == FALSE & startAtSmall == FALSE){
    mutation = "threshold"
  }else if (connectedness == FALSE & threshold == FALSE){
    mutation = "direction"
  }else if (threshold == FALSE){
    mutation = sample(c("connectedness","direction"),1)
  }else if (connectedness == FALSE){
    mutation = sample(c("threshold","direction"),1)
  }else if (startAtSmall == FALSE){
    mutation = sample(c("threshold","connectedness"),1)
  }else{
    mutation = sample(c("connectedness","threshold","direction"),1)
  }
  
  # execute the chosen mutation
  if (mutation == "connectedness"){
    # print("mutated connectedness")
    unusedLetters = setdiff(c(letters[1:10]), currentConnection)
    # possible mutations here are:
    # 1. switch 1 letter
    # 2. add one letter (only possible if the n of letters is < nOfMaxConnections)
    # 3. remove one letter (only possible if the n of letters is > 1)
    # 4. scramble the letters (only possible if n of letters is > 1)
    # lets check for the different case and choose one of the four mutations at random+
    if(length(currentConnection)<=1){
      choose = sample(1:2,1)
    }else if(length(currentConnection)>=nOfMaxConnections){
      choose = sample(c(1,3,4),1)
    }else{
      choose = sample(c(1:4),1)
    }
    if(choose == 1){
      # switch 1 letter
      currentConnection[sample(1:length(currentConnection),1)] = sample(unusedLetters,1)
    }else if (choose == 2){
      # add one letter
      # choose random insert position
      position = sample(1:(length(currentConnection)+1),1)
      if (position > length(currentConnection)){
        currentConnection = c(currentConnection,sample(unusedLetters,1))
      }else{
        currentConnection[position:(length(currentConnection)+1)] = c(sample(unusedLetters,1),
                                                                      currentConnection[position:length(currentConnection)])
      }
    }else if (choose == 3){
      # remove one letter
      currentConnection = currentConnection[-sample(1:length(currentConnection),1)]
    }else{
      # shuffeled the letters
      currentConnection = currentConnection[sample(1:length(currentConnection))]
    }
    
    # if the mutation is threshold
  } else if (mutation == "threshold"){
    # for the threshold mutation lets move the threshold up or down one
    if (currentThreshold <= 1){
      currentThreshold = currentThreshold+1
    }else if (currentThreshold >= nOfBars){
      currentThreshold = currentThreshold-1
    }else{
      currentThreshold = currentThreshold-sample(c(-1,1),1)
    }
  } else{
    currentStartAtSmall = setdiff(0:1,currentStartAtSmall)
  }
  particle$threshold = currentThreshold
  particle$connections = paste(currentConnection,collapse = "")
  particle$startAtSmall = currentStartAtSmall
  return(particle)
}

###########################
# function to run the simulation
############################
runSimulation = function(start_particles, # generated particles
                         total_runs, # int
                         trials, # int
                         particles_to_mutate, # int, number of particles that get mutated each trial
                         structure_query = FALSE, 
                         structure_task = FALSE){
  # matrix to collect run time
  times = matrix(0, trials, total_runs)
  accuracy = matrix(0, trials, total_runs)
  NoB = matrix(0, trials, total_runs) # Number of Bars
  finalHypotheses = data.frame(threshold = as.numeric(),
                               conncetions = as.character(),
                               startAtSmall = as.integer(),
                               time = as.numeric(),
                               run = as.numeric())
  # determine the number of hypotheses 
  nhypotheses = length(start_particles$threshold)
  print("number of hypotheses")
  print(nhypotheses)
  # for 20 simulations in total
  for (n_runs in 1:total_runs){
    print("started run:")
    print(n_runs)
    # generate a trial
    if(structure_query){
      trial = generatetrial(structure_query = TRUE)
    }else if(structure_task){
      trial = generatetrial(structure_task = TRUE)
    }else{
      trial = generatetrial()
    }
    
    print("current trial")
    print(trial)
    
    # create an out file
    # bind the output lists into data frame
    dout <- do.call(rbind, 
                    # apply trial to each program defined by the particles
                    apply(start_particles, 1, function(x) {execute(trial = trial, threshold = x[1], connect=x[2], startAtSmall = x[3])})
    )
    # bind them together
    hypotheses <- cbind(start_particles, dout)
    
    # go through 50 trials
    for (i in 1:trials){
      print("trial no:")
      print(i)
      print("hypotheses before selection")
      print(hypotheses)
      # generate new trial
      # generate a trial
      if(structure_query){
        trial = generatetrial(structure_query = TRUE)
      }else if(structure_task){
        trial = generatetrial(structure_task = TRUE)
      }else{
        trial = generatetrial()
      }
      
      NoB[i,n_runs] <- length(trial$bar)
      
      print("current trial")
      print(trial)
      print("hypotheses[,1:3]")
      print(hypotheses[,1:3])
      
      # collect results of all programs
      dout <- do.call(rbind, apply(hypotheses[,1:3], 1, function(x) {execute(trial = trial, threshold = x[1], connect = x[2], startAtSmall = x[3])}))
      print("dout")
      print(dout)
      # update time so that each hypotheses time reflects the average time
      hypotheses$time <- hypotheses$time*((i-1)/i) + (1/i)*dout$time
      # update accuracy
      hypotheses$correct <- dout$correct
      # only keep correct hypotheses
      hypotheses = subset(hypotheses, correct == 1)
      # see how many hypotheses are left
      remaining = length(hypotheses$correct)
      print("hypotheses after selection")
      print(hypotheses)
      print("remaining")
      print(remaining)
      
      # if all hypothese were wrong, generate entirely new ones
      if (remaining == 0){
        hypotheses = generateRandomParticles(nOfParticles = nhypotheses, 
                                             nOfBars= 7, 
                                             nOfMaxConnections = 3, 
                                             threshold = TRUE, 
                                             connectedness = TRUE,
                                             startAtSmall = TRUE)
        hypotheses <- cbind(hypotheses, dout)
        hypotheses$time = 0
        
      }else{
        # check if we can mutate as many particles as we wanted, and if not, update the number
        to_mutate = max(particles_to_mutate, nhypotheses-remaining)
        
        # remove the worst hypotheses and create the mutants
        mutants = data.frame(threshold = as.numeric(),
                             conncetions = as.character(),
                             startAtSmall = as.integer(),
                             time = as.numeric())
        for (ithBest in 1:to_mutate){
          # get the ith best hypothesis
          if (ithBest > remaining){
            # if there are to few hypotheses always mutate the best
            best = subset(hypotheses, time == sort(hypotheses$time)[1])[1,]
          }else{
            best = subset(hypotheses, time == sort(hypotheses$time)[ithBest])[1,]
          }
          print("hypotheses to muatate")
          print(best)
          # mutate that hypothesis
          mutant = mutateParticle(best, startAtSmall = FALSE)
          print("mutated hypotheses")
          print(mutant)
          mutants = rbind(mutants, mutant)
          
          
          # remove the worst hypothesis, but only of there are to many hypotheses
          if(length(mutants$time)+remaining > nhypotheses){
            hypotheses = hypotheses[-which.max(hypotheses$time),]
          }
        }
        # remove the rank from the hopotheses and add the mutants
        hypotheses = rbind(hypotheses, mutants)
      }
      # track max time
      times[i, n_runs] <- max(dout$time)
      # track mean accuracy
      accuracy[i,n_runs] <- mean(dout$correct)
      
      
    }
    print("run:")
    print(n_runs)
    print("final hypothese")
    print(hypotheses)
    dummy = hypotheses
    dummy$run = n_runs
    finalHypotheses = rbind(finalHypotheses, dummy)
  }
  output <- list()
  output[[1]] <- times
  output[[2]] <- accuracy
  output[[3]] <- finalHypotheses
  output[[4]] <- NoB
  return(output)
}

#################################################################################
# function to run model on participant data. 
# should take dataframe as input and should output:
# 1 the estimated rt
# the real rt
# accuracy 
# final hypotheses
###################################################################################

runHypoMutateOnData = function(start_particles, # generated particles
                               data, 
                               particles_to_mutate, # int, number of particles that get mutated each trial
                               mutate_threshold = TRUE,
                               mutate_connection = TRUE,
                               mutate_direction = TRUE
){
  trials = 35
  n_participants = length(unique(data$subject_id))
  # matrix to collect run time
  times = matrix(0, trials, n_participants)
  accuracy = matrix(0, trials, n_participants)
  NoB = matrix(0, trials, n_participants) # Number of Bars
  # participant data
  realRTs = matrix(0, trials, n_participants)
  realAccuracy = matrix(0, trials, n_participants)
  correctConnection = matrix(0, trials, n_participants)
  # save the correct connection
  if (data$Structure[1] == "Sequence"){
    for (i in 1:length(unique(data$subject_id))){
      theConnection = unlist(lapply(strsplit(subset(data, Number_of_Bars == 3 & subject_id == unique(data$subject_id)[i])$color_sequence[1], ",")[[1]], convert_colors))
      correctConnection[,i] = paste(theConnection, collapse = "")
    }
  }
  finalHypotheses = data.frame(threshold = as.numeric(),
                               conncetions = as.character(),
                               startAtSmall = as.integer(),
                               time = as.numeric(),
                               run = as.numeric())
  # determine the number of hypotheses 
  nhypotheses = length(start_particles$threshold)
  print("number of hypotheses")
  print(nhypotheses)
  # for 20 simulations in total
  for (participant in 1:n_participants){
    print("started participant:")
    print(participant)
    # get current trial
    current_trial = subset(data, subject_id == unique(data$subject_id)[participant])[1,]
    trial = datacolum_to_trial(current_trial)
    
    print("current trial")
    print(trial)
    
    # create an out file
    # bind the output lists into data frame
    dout <- do.call(rbind, 
                    # apply trial to each program defined by the particles
                    apply(start_particles, 1, function(x) {execute(trial = trial, threshold = x[1], connect=x[2], startAtSmall = x[3])})
    )
    # bind them togethers
    hypotheses <- cbind(start_particles, dout)
    
    # go through 50 trials
    for (i in 1:trials){
      print("trial no:")
      print(i)
      print("hypotheses before selection")
      print(hypotheses)
      # get current trial
      current_trial = subset(data, subject_id == unique(data$subject_id)[participant])[i,]
      trial = datacolum_to_trial(current_trial)
      
      NoB[i, participant] <- length(trial$bar)
      
      print("current trial")
      print(trial)
      print("hypotheses[,1:3]")
      print(hypotheses[,1:3])
      
      # collect results of all programs
      dout <- do.call(rbind, apply(hypotheses[,1:3], 1, function(x) {execute(trial = trial, threshold = x[1], connect = x[2], startAtSmall = x[3])}))
      print("dout")
      print(dout)
      # update time so that each hypotheses time reflects the average time
      hypotheses$time <- hypotheses$time*((i-1)/i) + (1/i)*dout$time
      # update accuracy
      hypotheses$correct <- dout$correct
      # only keep correct hypotheses
      hypotheses = subset(hypotheses, correct == 1)
      # see how many hypotheses are left
      remaining = length(hypotheses$correct)
      print("hypotheses after selection")
      print(hypotheses)
      print("remaining")
      print(remaining)
      
      # if all hypothese were wrong, generate entirely new ones
      if (remaining == 0){
        hypotheses = generateRandomParticles(nOfParticles = nhypotheses, 
                                             nOfBars = 7, 
                                             nOfMaxConnections = 3, 
                                             threshold = mutate_threshold, 
                                             connectedness = mutate_connection,
                                             startAtSmall = mutate_direction)
        hypotheses <- cbind(hypotheses, dout)
        hypotheses$time = 0
        print("had to replace all hypotheses, new hypotheses:")
        print(hypotheses)
        
      }else{
        # check if we can mutate as many particles as we wanted, and if not, update the number
        to_mutate = max(particles_to_mutate, nhypotheses-remaining)
        print("to mutate:")
        print(to_mutate)
        
        # remove the worst hypothese and create the mutants
        mutants = data.frame(threshold = as.numeric(),
                             conncetions = as.character(),
                             startAtSmall = as.integer(),
                             time = as.numeric())
        for (ithBest in 1:to_mutate){
          # get the ith best hypothesis
          if (ithBest > remaining | ithBest > 3){
            # if there are to few hypotheses always mutate the best
            # same, if its not in the best three
            best = subset(hypotheses, time == sort(hypotheses$time)[1])[1,]
          }else{
            best = subset(hypotheses, time == sort(hypotheses$time)[ithBest])[1,]
          }
          print("hypotheses to muatate")
          print(best)
          # mutate that hypothesis
          mutant = mutateParticle(best, 
                                  threshold = mutate_threshold, 
                                  connectedness = mutate_connection,
                                  startAtSmall = FALSE)
          print("mutated hypotheses")
          print(mutant)
          mutants = rbind(mutants, mutant)
          
        }
        # remove the worst hypotheses, but only of there are to many hypotheses
        while(length(mutants$time) + remaining > nhypotheses){
          remaining = remaining - 1
          hypotheses = hypotheses[-which.max(hypotheses$time),]
        }
        # remove the rank from the hopotheses and add the mutants
        hypotheses = rbind(hypotheses, mutants)
      }
      # track max time
      times[i, participant] <- max(dout$time)
      # track mean accuracy
      accuracy[i,participant] <- mean(dout$correct)
      # track real RT
      realRTs[i, participant] <- current_trial$rt
      # track real accuracy
      realAccuracy[i, participant] <- current_trial$correct
      
      print("trial number") 
      
    }
    print("run:")
    print(participant)
    print("final hypothese")
    print(hypotheses)
    dummy = hypotheses
    dummy$run = participant
    finalHypotheses = rbind(finalHypotheses, dummy)
  }
  output <- list()
  output[[1]] <- times
  output[[2]] <- realRTs
  output[[3]] <- accuracy
  output[[4]] <- realAccuracy
  output[[5]] <- finalHypotheses
  output[[6]] <- NoB
  output[[7]] <- correctConnection
  return(output)
}

#############################################################################
# function that runs the model on all data of all conditions
##########################################################################

runHypoMutateOnAllData <- function(start_particles,
                                  AllData,
                                  particles_to_mutate,
                                  mutate_threshold = TRUE,
                                  mutate_connection = TRUE,
                                  mutate_direction = TRUE){
  
  ###########################################
  # query Structure
  ############################################
  
  dQuery <- subset(AllData, Structure == "Query" & Condition == "Sort" & Stimulus_type == "bars")
  
  QueryDataOutput <- runHypoMutateOnData(start_particles,
                                         data = dQuery, 
                                         particles_to_mutate,
                                         mutate_threshold = mutate_threshold,
                                         mutate_connection = mutate_connection,
                                         mutate_direction = mutate_direction) 
  
  Querytimes <- QueryDataOutput[[1]]
  QueryrealRTs <- QueryDataOutput[[2]] 
  Queryaccuracy <- QueryDataOutput[[3]] 
  QueryrealAccuracy <- QueryDataOutput[[4]] 
  QueryfinalHypotheses <- QueryDataOutput[[5]] 
  QueryNoB <- QueryDataOutput[[6]]
  QuerytrueConnection <- QueryDataOutput[[7]]
  
  QueryfinalHypotheses$Structure = "Query"
  QueryfinalHypotheses$trueConnection = 0
  
  ModelToData = data.frame(NoB = as.numeric(),
                           time = as.numeric(),
                           realRT = as.numeric(),
                           accurcay = as.integer(),
                           realAccuracy = as.integer(),
                           trueConnection = as.character(),
                           participant = as.numeric(),
                           Structure = as.character(), 
                           trial = as.numeric())
  
  for (i in 1:length(unique(dQuery$subject_id))){
    ModelToData = rbind(ModelToData, data.frame(NoB = QueryNoB[,i],
                                                time = Querytimes[,i],
                                                realRT = QueryrealRTs[,i],
                                                accuracy = Queryaccuracy[,i],
                                                realAccuracy = QueryrealAccuracy[,i],
                                                trueConnection = "a",
                                                participant = unique(dQuery$subject_id)[i],
                                                Structure = "Query", 
                                                trial = 1:35))
  }
  
  ###########################################
  # Sequence Structure
  ############################################
  dSequence <- subset(AllData, Structure == "Sequence" & Condition == "Sort" & Stimulus_type == "bars")
  
  SequenceDataOutput <- runHypoMutateOnData(start_particles,
                                            data = dSequence, 
                                            particles_to_mutate,
                                            mutate_threshold = mutate_threshold,
                                            mutate_connection = mutate_connection,
                                            mutate_direction = mutate_direction) 
  
  Sequencetimes <- SequenceDataOutput[[1]]
  SequencerealRTs <- SequenceDataOutput[[2]] 
  Sequenceaccuracy <- SequenceDataOutput[[3]] 
  SequencerealAccuracy <- SequenceDataOutput[[4]] 
  SequencefinalHypotheses <- SequenceDataOutput[[5]] 
  SequenceNoB <- SequenceDataOutput[[6]]
  SequencetrueConnection <- SequenceDataOutput[[7]]
  
  SequencefinalHypotheses$Structure = "Sequence"
  SequencefinalHypotheses$trueConnection = SequencetrueConnection[1,]
  
  for (i in 1:length(unique(dSequence$subject_id))){
    ModelToData = rbind(ModelToData, data.frame(NoB = SequenceNoB[,i],
                                                time = Sequencetimes[,i],
                                                realRT = SequencerealRTs[,i],
                                                accuracy = Sequenceaccuracy[,i],
                                                realAccuracy = SequencerealAccuracy[,i],
                                                trueConnection = SequencetrueConnection[,i],
                                                participant = unique(dSequence$subject_id)[i],
                                                Structure = "Sequence", 
                                                trial = 1:35))
  }
  ###########################################
  # None Structure
  ############################################
  dNone <- subset(AllData, Structure == "None" & Condition == "Sort" & Stimulus_type == "bars")
  
  NoneDataOutput <- runHypoMutateOnData(start_particles,
                                        data = dNone, 
                                        particles_to_mutate,
                                        mutate_threshold = mutate_threshold,
                                        mutate_connection = mutate_connection,
                                        mutate_direction = mutate_direction) 
  
  Nonetimes <- NoneDataOutput[[1]]
  NonerealRTs <- NoneDataOutput[[2]] 
  Noneaccuracy <- NoneDataOutput[[3]] 
  NonerealAccuracy <- NoneDataOutput[[4]] 
  NonefinalHypotheses <- NoneDataOutput[[5]] 
  NoneNoB <- NoneDataOutput[[6]]
  NonetrueConnection <- NoneDataOutput[[7]]
  
  NonefinalHypotheses$Structure = "None"
  NonefinalHypotheses$trueConnection = 0
  
  for (i in 1:length(unique(dNone$subject_id))){
    ModelToData = rbind(ModelToData, data.frame(NoB = NoneNoB[,i],
                                                time = Nonetimes[,i],
                                                realRT = NonerealRTs[,i],
                                                accuracy = Noneaccuracy[,i],
                                                realAccuracy = NonerealAccuracy[,i],
                                                trueConnection = "a",
                                                participant = unique(dNone$subject_id)[i],
                                                Structure = "None", 
                                                trial = 1:35))
  }
  allfinalHypo = rbind(NonefinalHypotheses, QueryfinalHypotheses, SequencefinalHypotheses)
  output <- list()
  output[[1]] <- ModelToData
  output[[2]] <- allfinalHypo
  return(output)
}




#################################################
# necessary extra functions for working with the actual data
###############################################
convert_colors <- function(color){
  colors = c("green", "blue", "red", "purple", "saddlebrown", "white", "orange", "black", "yellow", "pink")
  myletters = c(letters[1:length(colors)])
  for (i in 1:length(colors)){
    if (colors[i] == color){
      return(myletters[i])
    }
  }
  print("no match found")
}

convert_postion_seq_to_height_order <- function(position_sequence){
  position_sequence <- lapply(strsplit(position_sequence, ","), as.numeric)[[1]]
  # the following is only necessary, because apperently somtiems the positions where wrongly saved (e.g. 390 as 39)
  for (i in 1:length(position_sequence)){
    while(position_sequence[i] < 100){
      position_sequence[i] <- position_sequence[i]*10
    } 
  }
  postions_in_order <- sort.int(position_sequence)
  positions <- 1:length(position_sequence)
  for (i in 1:length(position_sequence)){
    positions[i] = which(position_sequence == postions_in_order[i])
  }
  return(positions)
}

datacolum_to_trial <- function(trialData){  # d[i,]
  heights <- convert_postion_seq_to_height_order(trialData$position_sequence)
  target <- convert_colors(trialData$Query_color)
  bars <- unlist(lapply(strsplit(trialData$color_sequence, ",")[[1]][heights], convert_colors))
  trial <- data.frame(bar = bars, size = heights, target = target)
  return(trial)
}


#############################################################################

#standard error
se <- function(x){sd(x)/sqrt(length(x))}